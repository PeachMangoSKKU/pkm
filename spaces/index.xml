<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Spaces on</title><link>https://shihyuho.github.io/pkm/spaces/</link><description>Recent content in Spaces on</description><generator>Hugo -- gohugo.io</generator><language>zh-tw</language><atom:link href="https://shihyuho.github.io/pkm/spaces/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>https://shihyuho.github.io/pkm/spaces/ddd/aggregate/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shihyuho.github.io/pkm/spaces/ddd/aggregate/</guid><description>Aggregate Event , Command, User 等所有便利貼的集合 使用名詞, 不要出現動詞 避免使用不精確的名詞 一個 Aggregate 對應一個 Repository 如果是要協調調度兩個不同的聚合的情況下，一般我們會考慮是以 Application Service 來處理，或者是通過派發領域事件去跟另一個聚合做交互， domain service 還是比較隸屬於該聚合相關的業務話題的事物居多。
Aggregate Root 一個 Aggregate Root擁有 domain event list 就好像是一個汽車修理員隨身攜帶螺絲起子一樣是很自然的事情
聚合根持有整體的領域事件，並且決定何時發出去。</description></item><item><title/><link>https://shihyuho.github.io/pkm/spaces/ddd/bounded-context/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shihyuho.github.io/pkm/spaces/ddd/bounded-context/</guid><description>Bounded Context 盡可能的具象化 等於是 Aggregate 的群組 Dealing with Relationships 找出各個 Bounded Context 的上下文
U: Upstream 上文 D: Downstream 下文 如果找到上下文之間有 cycle 關係, 代表這些參與 cycle 的 bounded context 的關係有問題, 有可能其實是同一個</description></item><item><title/><link>https://shihyuho.github.io/pkm/spaces/ddd/bridge-pattern/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shihyuho.github.io/pkm/spaces/ddd/bridge-pattern/</guid><description>Bridge Pattern 橋接模式最主要就是將你的物件切分成概念與行為(殼與肉)，達到極致的解偶獨立，例如，遙控器他只是一個塑膠殼(概念)搭配一個電子電路版(行為)，如果我將電子電路版做成通用，以後遙控器的殼可以跟隨市場上流行的板式直接使用我的電子電路版。
Class Diagram Abstraction: 將原本的主體抽換到只剩下虛擬的概念，例如(人類:只是吃喝拉撒睡的主體、遙控器:只是開機關機調整的主體)
Class Diagram RefineAbstraction: 根據不同的需求實作主體
Implementator: 將原本主體的實際功能抽離，成為這個的Hierarchy(繼承結構)，例如(人類:人類的吃和拉撒睡拉出在此結構實作)
ConcreteImplementator: 根據不同的需求開發真實的行為
![[spaces/ddd/attachments/bridge-pattern.png]]
Example 在 Application 中我們定義 repository interface, 也就是 Bridge Pattern 的 Abstraction, 其中只會列出該 aggregate 中會用到的動作
例如在 Balance Aggregate 中, 我們會使用到:
getCurrentBalance: 取得當前的餘額 save: 更新餘額 1 2 3 4 5 6 7 pacakge example.application.balance.repository; @FunctionInterface interface BalanceRepository { Balance getCurrentBalance(); void save(Balance balance); } 接的在 Infrastructure package 中去實作 Domain repository, 也就是 Bridge Pattern 的 RefineAbstraction, 這邊通常也是管理 Transaction 的地方, 而且這邊也不直接操作 Persistence framework (如 JPA), 取代代之的是傳入 Dao</description></item><item><title/><link>https://shihyuho.github.io/pkm/spaces/ddd/command/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shihyuho.github.io/pkm/spaces/ddd/command/</guid><description>Command 通常是 Event 的倒裝, 例如: Event 是買了鞋子, Command 就是 買鞋
便利貼顏色 使用藍色</description></item><item><title/><link>https://shihyuho.github.io/pkm/spaces/ddd/domain-modeling/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shihyuho.github.io/pkm/spaces/ddd/domain-modeling/</guid><description>Domain Modeling Aggregate Event Storming 的 Aggregate 實作後比較像 Domain Modeling 的界線, 通常會再分:
Aggregate Root Entity Value Object Aggregate Root 可以從生命週期來看, 當某一件事在某個時間點結束時, 相關的資料也會跟的消失, 就樣就適合當成 Root
在 Root 中可以從 public getter, private setter 開始設計
怎麼找出 VO 或 Entity 先在 Event Storming 的 Aggregate 中, 試著找到所有相關的名詞, 使用紫色便條紙, 這可以是很細節
在這些紫色便條紙中, 依序往下區分
Value Object Descriptive aspect of domain, 是一種描述, 肚量 domain 的性質
Immutable value Non-identical life cycle concept Entity 在 Value Object 中, 有狀態, 生命週期的, 改成定義為 Entity 定義 Entity Id, Id 基本上也是 Value Object, 就算只有一個欄位也是這樣建議 Entity ID 可以是以下方式:</description></item><item><title/><link>https://shihyuho.github.io/pkm/spaces/ddd/event/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shihyuho.github.io/pkm/spaces/ddd/event/</guid><description>Event 事件，也稱領域事件，即不可抹滅的事實, 使用過去式表達
便利貼顏色 使用橘色 或使用紫色便利貼, 紫色代表一個長流程, 也就是橘色的集合 事件捕捉 透過 Event Storming 找出事件, 關鍵有：
統一語言 ubiquitous language 限界上下文 bounded context 即在不同上下文之間, 講不同語言
改系統，一定要有 business wish/value/goal，否則失敗率極高</description></item><item><title/><link>https://shihyuho.github.io/pkm/spaces/ddd/example-mapping/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shihyuho.github.io/pkm/spaces/ddd/example-mapping/</guid><description>Example Mapping Use Case 在 Bounded Context 中, 試著找出很多 Use Case, 使用黃色便條紙寫上
Rule 在黃色的 Use Case 中, 找出很多 Rule, 使用藍色的便條紙
Example 從 Rule 中找出範例, 使用綠色便條紙 範例應該包含 Use Case 的正反向流程 (成功/失敗) Question 過程中想到什麼問題, 列成紅色的便條紙
希望得到 發現並擴展問題域, 甚至找到新的 User Mapping Acceptance Tests Sharing Understanding Gherkin https://cucumber.io/
Given: 前置條件設定 When: 發生了一個事件, 通常可以就是 Command Then: 預期結果 And: 多個 Given (前置條件) 的串接 But: 多個 Then (預期結果) 的串接 Examples: 定義變數</description></item><item><title/><link>https://shihyuho.github.io/pkm/spaces/ddd/repository/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shihyuho.github.io/pkm/spaces/ddd/repository/</guid><description>Repository 一個 [[spaces/ddd/aggregate]] 對應一個 Repository
兩種類型 依據 DDD 紅皮書的分析，Repository有兩種：
Collection-like CRUD-like Martin Follower PoEAA書中的repository是collection-like，但一般我們常用的是CRUD-like，需要額外呼叫save儲存aggregate。所以當你決定使用Repository pattern，你要決定使用哪一種風格的repository。
的目 Repository 的目的是要隔離領域物件(aggregate)與資料庫操作。
從領域物件的角度來看 ，根本不需要知道 Repository 的實作, Ex: 有哪些 Entity? 對應多少個 Data Object?
Pattern 通常是分析到最後，才需要關心Repository的實作, 在 DDD 加上 Clean Architecture 的情況下, 實作套 [[spaces/ddd/bridge-pattern]] 通常就搞定了!
Repository 原本就是一個介面，就算你針對某個實作版本不滿意，不管是效能還是其他原因，換 Repository 的實作即可。
當然沒事不會常常換，因為換掉之後後端的資料庫可能需要隨著改變。如果已經有production的資料在上面，會比較麻煩。</description></item><item><title/><link>https://shihyuho.github.io/pkm/spaces/ddd/strategic-design/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shihyuho.github.io/pkm/spaces/ddd/strategic-design/</guid><description>Strategic Design 戰略
Event Command User Read Model Third Party Aggregate Bounded Context Subdomain 執行順序 匡圈 DDD 範圍, 在發想時如果已知超過範圍, 可使用粉紅色表示, 其代表另一個複雜流程 定義 Command (藍色) 跟 User(黃色) 在 Command 跟 Event 之中找 Logic (黃色), 勢必會打破原本的橘, 紫色 Aggregate 聚合所有便利貼 找 Bounded Context Sticky Note 橘色: 已經發生的事實，不可改變，使用過去式 紫色: 大流程, 即橘色的群組 粉紅: Third/External Party 黃色: User/Role 藍色: Command</description></item><item><title/><link>https://shihyuho.github.io/pkm/spaces/ddd/subdomain/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shihyuho.github.io/pkm/spaces/ddd/subdomain/</guid><description>Subdomain SubDomain 可分:
Generic Subdomain Support Subdomain Core Subdomain Generic Subdomain 輪子不用再造, 找其他現成軟體或其他廠商的 API, 如: email, sms, 加密等
Support Subdomain 用來支撐 core 的 subdomain
Core Subdomain 最關注的 domain, 通常是改造的目標</description></item><item><title/><link>https://shihyuho.github.io/pkm/spaces/ddd/tactical-design/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shihyuho.github.io/pkm/spaces/ddd/tactical-design/</guid><description>Tactical Design 戰術
提高系統存活率 Living Document - 讓文件語言跟程式語言儘量一至 Bubble - 讓一些還沒有要疏離的系統, Infrastructure - CICD, Auto test Architecture - Re-modular Module in Monolith first
Core Domain Pattern X軸: Model Complicity Y軸: Business Differentiation
Table stakes former core Short-term core Hidden core Black swan core ArchUnit 測試程式依賴的工具 https://www.archunit.org/use-cases
資料結構 maven submodule: bounded context aggregate 放 domain 中 Domain Modeling Example Mapping</description></item><item><title/><link>https://shihyuho.github.io/pkm/spaces/event-sourcing/general-understanding/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shihyuho.github.io/pkm/spaces/event-sourcing/general-understanding/</guid><description>General Understanding 在經過 DDD 的洗禮之後, 我們會有很多 Event , 包含了 Event type 跟 Data。我們會將這些 Event 有順序性的儲存在 Stream 中 (通常就採用 Event 的建立順序)，然後再將這些 Stream 儲存到 EventStore 中, 並為每個 Event 產生獨一無二的 ID。
接著我們會透過 Projection 將 Stream 中的所有 Events 去計算出 Aggregate 的 current state, 為了方便使用, 我們也可以將 current state 儲存成一個 Read Model</description></item><item><title/><link>https://shihyuho.github.io/pkm/spaces/event-sourcing/guarantee-correctness-when-writing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shihyuho.github.io/pkm/spaces/event-sourcing/guarantee-correctness-when-writing/</guid><description>Guarantee Correctness when writing 由於 Read Model 所提供的資訊, 同時有機會被多個服務或是 Thread 使用, u有個經典的提款問題: 兩個 Thread 在檢查同一帳戶餘額時都是通過的, 但一起下提款 Command 時, 你的帳戶就超支囉!
Manage Transactions with a database 這種狀況我們需要的是在 Event Store 之前放一個 Transaction Database 去管理 Transaction
我們使用一個 Database 擋在 Event Store 之前, 在使用 [[CDC]] 抓取 Event Stream 到 Event Store 中, 在個 Database 即稱為 Transaction Database
以下圖為例
Transaction Database 使用 Couchbase Event Store 使用 Kafka 當 Order Service 接到 Bug Command 時, 寫的是 Couchbase, 在這邊管理多個 Order Service Instance 或多個 Thread 的 Transaction</description></item><item><title/><link>https://shihyuho.github.io/pkm/spaces/event-sourcing/projection/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shihyuho.github.io/pkm/spaces/event-sourcing/projection/</guid><description>Projection Projection 就是用來處理 event 的程式邏輯, 基本上就是一推 Event Handlers!
例, 我們有以下 event:
UserCreated UserOnboarded UserRelocated 則 Current User Projection 的內容大概是:
而產出會是 Aggregate</description></item><item><title/><link>https://shihyuho.github.io/pkm/spaces/event-sourcing/read-model/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shihyuho.github.io/pkm/spaces/event-sourcing/read-model/</guid><description>Read Model Read Model 可以說是在 Event Store 中, 特定的 Event of Stream 的產出。
以程式來看, 大概像是:
1 2 var readModel = Stream.of(events) .leftFold(handlers) 這個產出, 通常也就是會被儲存在每個服務自己的 db 中</description></item><item><title/><link>https://shihyuho.github.io/pkm/spaces/event-sourcing/you-may-not-need-a-read-model/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shihyuho.github.io/pkm/spaces/event-sourcing/you-may-not-need-a-read-model/</guid><description>You may NOT need a read model Read Model 會有一些 Trade off:
最終一致性 該如何 Replays and Rebuilds 該如何 Re-Deliveries Read Db 的維運成本 換個角度想, 如果不要有 Read Model 呢?
我們如果在讀取 Event Store 時, 就依照 Aggregate ID 過濾 Stream, 把 Stream 最小化
回到使用端, 在 runtime 要取得 current state 時, 程式在即時的去運算出 current state 的 Aggregate
由於我們把 Stream 最小化了, 效能仍不錯, 而且也沒有了那些 Trade off!
如果需要透過條件去查詢, 可能要使用到一些 Event Store 所提供 Category Projection 了!
在 Event Store 中就可以先將 Event 分類後再讀出 Stream 了!</description></item><item><title/><link>https://shihyuho.github.io/pkm/spaces/kubernetes/assigning-pods/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://shihyuho.github.io/pkm/spaces/kubernetes/assigning-pods/</guid><description>Assigning Pods 在部署 Deployment 時, 有些情況我們會希望 Kubernetes 依照我們的需求來安排部署的 Node, 例如:
當我們開多份 Replicas 時, 希望這些 Replicas 時儘量不要安排到同一個 Node 上 不同的部署但性質相雷同的程式, 例如資源需求 (如 CPU 運算) 較高等, 希望儘量不要安排到同一個 Node 上 Affinity 在 spec.affinity 下一共有 podAffinity (正向) 或 podAntiAffinity (反向), 這是用來約束 Kubernetes 該怎麼安排 Pod 到 Node 上, 這兩種 affinity 中都有兩種 type 可以使用:
requiredDuringSchedulingIgnoredDuringExecution - Hard requirement, 要求 Kubernetes 依照設定安排, 沒滿足就不部署 Pod preferredDuringSchedulingIgnoredDuringExecution - Soft requirement, 建議 Kubernetes 儘量滿足設定安排, 無法滿足仍要部署 Pod Use Case 以下我們範例是一個常見的需求: 建議 Kubernetes 將多個 replicas 儘量分散到不同的 Node 中</description></item></channel></rss>